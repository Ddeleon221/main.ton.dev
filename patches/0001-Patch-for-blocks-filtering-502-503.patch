From 07656a9a089dccdf4d219ac9023e3e320714ccdf Mon Sep 17 00:00:00 2001
From: Leny Kholodov <leonid.k@tonlabs.io>
Date: Thu, 25 Jun 2020 15:32:31 +0000
Subject: [PATCH] Patch for blocks filtering 502 & 503

---
 validator-engine/validator-engine.cpp |  1 +
 validator/block-handle.hpp            |  2 +-
 validator/impl/fabric.cpp             | 31 ++++++++++++++++
 validator/import-db-slice.cpp         |  5 +++
 validator/manager.cpp                 |  5 ++-
 validator/state-serializer.cpp        | 52 ++++++++++++++++++++++++---
 6 files changed, 90 insertions(+), 6 deletions(-)

diff --git a/validator-engine/validator-engine.cpp b/validator-engine/validator-engine.cpp
index 7d40dda..1849032 100644
--- a/validator-engine/validator-engine.cpp
+++ b/validator-engine/validator-engine.cpp
@@ -1326,6 +1326,7 @@ td::Status ValidatorEngine::load_global_config() {
   if (truncate_seqno_ > 0) {
     validator_options_.write().truncate_db(truncate_seqno_);
   }
+  validator_options_.write().add_unsafe_catchain_rotate(1066501, 15547, 15);
 
   std::vector<ton::BlockIdExt> h;
   for (auto &x : conf.validator_->hardforks_) {
diff --git a/validator/block-handle.hpp b/validator/block-handle.hpp
index 372c614..654f4de 100644
--- a/validator/block-handle.hpp
+++ b/validator/block-handle.hpp
@@ -332,7 +332,7 @@ struct BlockHandleImpl : public BlockHandleInterface {
   }
   void set_next_left(BlockIdExt next) {
     auto f = flags_.load(std::memory_order_consume);
-    if (f & Flags::dbf_inited_next_left) {
+    if ((f & Flags::dbf_inited_next_left) && !(id_.id.workchain == -1 && (id_.id.seqno == 1066501 || id_.id.seqno == 1066502) && id_.id.shard == 9223372036854775808ULL)) {
       LOG_CHECK(next_[0] == next) << "id=" << id_ << " next=" << next_[0] << " to_be_next=" << next;
     } else {
       lock();
diff --git a/validator/impl/fabric.cpp b/validator/impl/fabric.cpp
index ac296eb..027e9bb 100644
--- a/validator/impl/fabric.cpp
+++ b/validator/impl/fabric.cpp
@@ -39,6 +39,13 @@ namespace ton {
 
 namespace validator {
 
+bool should_skip(BlockIdExt id)
+{
+  return (std::string(id.file_hash.to_hex()) == std::string("0131FF3F57971D89C25F31D8BEB0314479037D6572E1FED761A0CDFAE16AE4C6")) ||
+      (std::string(id.file_hash.to_hex()) == std::string("A434E180A6E53854BB24683773E76A82584A46C75ADF25E01132A7AB3F974C28")) ||
+      (std::string(id.file_hash.to_hex()) == std::string("BEFCFF0D1A4AA9A777BB2100654F2EBEB4105C3F14CF76161040D9014ACA20A8"));
+}
+
 td::actor::ActorOwn<Db> create_db_actor(td::actor::ActorId<ValidatorManager> manager, std::string db_root_) {
   return td::actor::create_actor<RootDb>("db", manager, db_root_);
 }
@@ -125,6 +132,21 @@ void run_accept_block_query(BlockIdExt id, td::Ref<BlockData> data, std::vector<
                             td::Ref<ValidatorSet> validator_set, td::Ref<BlockSignatureSet> signatures,
                             td::Ref<BlockSignatureSet> approve_signatures, bool send_broadcast,
                             td::actor::ActorId<ValidatorManager> manager, td::Promise<td::Unit> promise) {
+  if (should_skip(id))
+  {
+    //LOG(ERROR) << "!!!! SKIP ACCEPTING " << id;
+    promise.set_error(td::Status::Error(ErrorCode::timeout, "!!!TIMEOUT!"));
+    return;
+  }
+/*  for (auto prev_id : prev)
+  {
+    if (should_skip(prev_id))
+    {
+      promise.set_error(td::Status::Error(ErrorCode::timeout, "!!!TIMEOUT!"));
+      return;
+    }
+  }*/
+  LOG(ERROR) << "ACCEPT ID " << id << " with file_hash=" << id.file_hash.to_hex();
   td::actor::create_actor<AcceptBlockQuery>("accept", id, std::move(data), prev, std::move(validator_set),
                                             std::move(signatures), std::move(approve_signatures), send_broadcast,
                                             manager, std::move(promise))
@@ -150,6 +172,15 @@ void run_hardfork_accept_block_query(BlockIdExt id, td::Ref<BlockData> data,
 void run_apply_block_query(BlockIdExt id, td::Ref<BlockData> block, BlockIdExt masterchain_block_id,
                            td::actor::ActorId<ValidatorManager> manager, td::Timestamp timeout,
                            td::Promise<td::Unit> promise) {
+                           
+  
+  if (should_skip(id) || should_skip(masterchain_block_id))
+  {
+    //LOG(ERROR) << "!!!! SKIP APPLYING " << id;
+    promise.set_error(td::Status::Error(ErrorCode::timeout, "!!!TIMEOUT!"));
+    return;
+  }
+  LOG(ERROR) << "APPLY ID " << id << " with file_hash=" << id.file_hash.to_hex() << "; MS: " << masterchain_block_id << ", with file_hash=" << masterchain_block_id.file_hash.to_hex();
   td::actor::create_actor<ApplyBlock>(PSTRING() << "apply " << id, id, std::move(block), masterchain_block_id, manager,
                                       timeout, std::move(promise))
       .release();
diff --git a/validator/import-db-slice.cpp b/validator/import-db-slice.cpp
index a93fb05..2e0dc29 100644
--- a/validator/import-db-slice.cpp
+++ b/validator/import-db-slice.cpp
@@ -198,6 +198,11 @@ void ArchiveImporter::check_masterchain_block(BlockSeqno seqno) {
 void ArchiveImporter::checked_masterchain_proof(BlockHandle handle, td::Ref<BlockData> data) {
   CHECK(data.not_null());
   auto P = td::PromiseCreator::lambda([SelfId = actor_id(this), handle](td::Result<td::Unit> R) {
+    if (R.is_error())
+    {
+      LOG(ERROR) << "MASTERCHAIN PROOF ERROR";
+      return;
+    }
     R.ensure();
     td::actor::send_closure(SelfId, &ArchiveImporter::applied_masterchain_block, std::move(handle));
   });
diff --git a/validator/manager.cpp b/validator/manager.cpp
index dcd3f89..fd7e449 100644
--- a/validator/manager.cpp
+++ b/validator/manager.cpp
@@ -1762,6 +1762,7 @@ void ValidatorManagerImpl::update_shards() {
     auto val_set = last_masterchain_state_->get_validator_set(ShardIdFull{masterchainId});
     auto r = opts_->check_unsafe_catchain_rotate(last_masterchain_seqno_, val_set->get_catchain_seqno());
     force_recover = r > 0;
+    LOG(WARNING) << "masterseq=" << last_masterchain_seqno_ << " catchainseqno=" << val_set->get_catchain_seqno() << " r=" << r;    
   }
 
   BlockSeqno key_seqno = last_key_block_handle_->id().seqno();
@@ -1797,7 +1798,7 @@ void ValidatorManagerImpl::update_shards() {
           }
         }
 
-        VLOG(VALIDATOR_DEBUG) << "validating group " << val_group_id;
+        VLOG(WARNING) << "validating group " << val_group_id << ":::: shard=" << shard << ", opts_hash=" << opts_hash << ", key_seqno=" << key_seqno;
         auto it = validator_groups_.find(val_group_id);
         if (it != validator_groups_.end()) {
           new_validator_groups_.emplace(val_group_id, std::move(it->second));
@@ -1918,8 +1919,10 @@ ValidatorSessionId ValidatorManagerImpl::get_validator_set_id(ShardIdFull shard,
   std::vector<tl_object_ptr<ton_api::validator_groupMember>> vec;
   auto v = val_set->export_vector();
   auto vert_seqno = opts_->get_maximal_vertical_seqno();
+  LOG(ERROR) << " validators count=" << v.size() << ", vertseqno=" << vert_seqno;
   for (auto &n : v) {
     auto pub_key = PublicKey{pubkeys::Ed25519{n.key}};
+    LOG(ERROR) << "  weight=" << n.weight << ", pubkey=" << pub_key.compute_short_id().bits256_value();
     vec.push_back(
         create_tl_object<ton_api::validator_groupMember>(pub_key.compute_short_id().bits256_value(), n.addr, n.weight));
   }
diff --git a/validator/state-serializer.cpp b/validator/state-serializer.cpp
index 802159c..3c95e00 100644
--- a/validator/state-serializer.cpp
+++ b/validator/state-serializer.cpp
@@ -38,11 +38,37 @@ void AsyncStateSerializer::start_up() {
   td::actor::send_closure(manager_, &ValidatorManager::get_async_serializer_state, std::move(P));
 }
 
+namespace
+{
+
+Bits256 from_hex(const char* str)
+{
+  Bits256 result;
+  result.from_hex(td::Slice(str, str + strlen(str)));
+  return result;
+}
+
+}
+
 void AsyncStateSerializer::got_self_state(AsyncSerializerState state) {
   if (state.last_block_id.is_valid()) {
-    last_block_id_ = state.last_block_id;
-    last_key_block_id_ = state.last_written_block_id;
-    last_key_block_ts_ = state.last_written_block_ts;
+    LOG(ERROR) <<" !!! FORCE CHECK: last_block_id=" << last_block_id_ << ", state.last_block_id=" << state.last_block_id << ", state.last_written_block_id=" << state.last_written_block_id;
+    if ((last_block_id_.id.seqno >= 1066500 && last_block_id_.id.seqno < 1066510) && state.last_block_id.id.workchain == -1 && state.last_block_id.id.shard == 9223372036854775808ULL)
+    {
+      last_block_id_.id.seqno = 1066501;
+      last_block_id_.root_hash = from_hex("8E0900AA7D0FAAC5F3751BEE0394868F089F1745935A8A30F6EAC83DBAB3FC3D");
+      last_block_id_.file_hash = from_hex("48246C5F7A21A313A1A6F54A9E747D84001A02FE6C9F644D6E72ECAA1D2E40E6");
+      last_key_block_id_ = state.last_written_block_id;
+      last_key_block_ts_ = state.last_written_block_ts;
+      
+      LOG(ERROR) << "FORCE SERIALIZER MS BLOCK RESET TO " << last_block_id_;
+    }
+    else {
+      last_block_id_ = state.last_block_id;
+      last_key_block_id_ = state.last_written_block_id;
+      last_key_block_ts_ = state.last_written_block_ts;
+    }
+    LOG(ERROR) << "set SELF state last_block_id=" << last_block_id_ << " last key block = " << last_key_block_id_;
 
     running_ = false;
 
@@ -61,6 +87,8 @@ void AsyncStateSerializer::got_init_handle(BlockHandle handle) {
   last_key_block_id_ = handle->id();
   last_key_block_ts_ = handle->unix_time();
 
+  LOG(ERROR) << __FILE__ << "(" << __LINE__ << "): init "<< handle->id();
+
   masterchain_handle_ = std::move(handle);
 
   running_ = false;
@@ -85,19 +113,24 @@ void AsyncStateSerializer::next_iteration() {
   if (running_) {
     return;
   }
+      LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
   if (!masterchain_handle_) {
     running_ = true;
     auto P = td::PromiseCreator::lambda([SelfId = actor_id(this)](td::Result<BlockHandle> R) {
       R.ensure();
       td::actor::send_closure(SelfId, &AsyncStateSerializer::got_masterchain_handle, R.move_as_ok());
     });
+    LOG(ERROR) << "last block ID is " << last_block_id_;
     td::actor::send_closure(manager_, &ValidatorManager::get_block_handle, last_block_id_, true, std::move(P));
     return;
   }
+        LOG(ERROR) << __FILE__ << "(" << __LINE__ << "): inited_time=" << masterchain_handle_->inited_unix_time() << " inited_key_block=" << masterchain_handle_->inited_is_key_block() <<
+        " applied=" << masterchain_handle_->is_applied() << " ms_id" << masterchain_handle_->id();
   if (!masterchain_handle_->inited_unix_time() || !masterchain_handle_->inited_is_key_block() ||
       !masterchain_handle_->is_applied()) {
     return;
   }
+        LOG(ERROR) << __FILE__ << "(" << __LINE__ << "): !!!";
   CHECK(masterchain_handle_->id() == last_block_id_);
   if (attempt_ < max_attempt() && last_key_block_id_.id.seqno < last_block_id_.id.seqno &&
       need_serialize(masterchain_handle_)) {
@@ -115,6 +148,7 @@ void AsyncStateSerializer::next_iteration() {
       td::actor::send_closure(manager_, &ValidatorManager::get_shard_state_from_db, masterchain_handle_, std::move(P));
       return;
     }
+          LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
     while (next_idx_ < shards_.size()) {
       if (!need_monitor(shards_[next_idx_].shard_full())) {
         next_idx_++;
@@ -128,10 +162,12 @@ void AsyncStateSerializer::next_iteration() {
         return;
       }
     }
+          LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
     last_key_block_ts_ = masterchain_handle_->unix_time();
     last_key_block_id_ = masterchain_handle_->id();
   }
   if (!saved_to_db_) {
+        LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
     running_ = true;
     auto P = td::PromiseCreator::lambda([SelfId = actor_id(this)](td::Result<td::Unit> R) {
       R.ensure();
@@ -142,25 +178,33 @@ void AsyncStateSerializer::next_iteration() {
                             std::move(P));
     return;
   }
+  LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
   if (masterchain_handle_->inited_next_left()) {
+    LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
     last_block_id_ = masterchain_handle_->one_next(true);
     masterchain_state_ = td::Ref<MasterchainState>{};
+    LOG(ERROR) << __FILE__ << "(" << __LINE__ << "): "<< "RESET MS HANDLE";
     masterchain_handle_ = nullptr;
     saved_to_db_ = false;
     shards_.clear();
     next_idx_ = 0;
     next_iteration();
   }
+  LOG(ERROR) << __FILE__ << "(" << __LINE__ << "):";
 }
 
 void AsyncStateSerializer::got_top_masterchain_handle(BlockIdExt block_id) {
   if (masterchain_handle_ && masterchain_handle_->id().id.seqno < block_id.id.seqno) {
-    CHECK(masterchain_handle_->inited_next_left());
+    LOG(ERROR) << "old masterchain has seqno " << masterchain_handle_->id() <<", new masterchain handle seqno is " << block_id;
+    {
+      //CHECK(masterchain_handle_->inited_next_left());
+    }
   }
 }
 
 void AsyncStateSerializer::got_masterchain_handle(BlockHandle handle) {
   CHECK(!masterchain_handle_);
+  LOG(ERROR) << __FILE__ << "(" << __LINE__ << "): got new MS handle "<< handle->id();
   masterchain_handle_ = std::move(handle);
   running_ = false;
   attempt_ = 0;
-- 
2.27.0

